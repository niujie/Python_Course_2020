\documentclass{beamer}

\usepackage{minted}
\setminted[python]{
  xleftmargin=10pt,linenos,
  style=monokai,bgcolor=pythoncodebg,
  mathescape,texcl,
  fontsize=auto}

\usetheme{CambridgeUS}
\definecolor{pythoncodebg}{HTML}{282828}

\title{Python Bascics 2}
\author{Jie Niu}
\institute{IGWES, JNU}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\section{Python Functions}
\subsection{Functions}

\begin{frame}[fragile]{Functions}
The purpose of using function (in any programming language) is - \textbf{RE-USING} it.\\
\begin{minted}{python}
>>> def f():
...     pass
...
>>> f()
>>> f
<function f at 0x123ABCDEF>
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Functions}
\begin{minted}{python}
>>> def ping():
...     return "Ping!"
...
>>> ping()
'Ping!'
>>> x = ping()
>>> print(x)
Ping!
>>> dir()
['__builtins__', ... ..., 'f', 'ping', 'x']
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Functions with argument}
\begin{minted}{python}
>>> import math
>>> math.pi
3.141592653589793
>>> def volume(r):
...     """Returns the volume of a sphere 
...        with radius r."""
...     v = (4.0/3.0) * math.pi * r**3
...     return v
...
>>> volume(2)
33.510321638291124
>>> volume()
... ...
TypeError: volume() takes exactly 1 argument (0 given)
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Functions: docstrings, multiple arguments}
\begin{minted}{python}
>>> help(volume)
Help on function volume in module __main__:

volume(r)
Returns the volume of a sphere with radius r.
>>>
>>> def triangle_area(b, h):
...     """Returns the area of a triangle
...        with base b and height h."""
...     return 0.5 * b * h
...
>>> triangle_area(3, 6)
9.0
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Functions with keyword (default) arguments}
\begin{minted}[fontsize=\footnotesize]{python}
>>> def cm(feet = 0, inches = 0):
...  """Converts a length from feet and inches to centimeters."""
...  inches_to_cm = inches * 2.54
...  feet_to_cm = feet * 12 * 2.54
...  return inches_to_cm + feet_to_cm
...
>>> cm(feet = 5)
152.4
>>> cm(inches = 70)
177.8
>>> cm(feet = 5, inches = 8)
172.72
>>> cm(inches = 8, feet = 5)
172.72
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Types of Arguments}
\begin{itemize}
  \item keyword
  \item Required
\end{itemize}
\begin{minted}[fontsize=\small]{python}
>>> def g(x = 0, y):
...     return x + y
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
>>> def g(y, x = 0):
...     return x + y
...
>>> g(5)
5
>>> g(7, x = 3)
10
>>>
\end{minted}
\end{frame}

\section{Data Stuctures}
\subsection{Set}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> example = set()
>>> dir(example)
[... ..., 'add', ... ...]
>>> help(example.add)
Help on built-in function add:

add(...) method of builtins.set instance
    Add an element to a set.
    This has no effect if the element is already present.

>>> example.add(42)
>>> example.add(False)
>>> example.add(3.14159)
>>> example.add("Thorium")
\end{minted}
\end{frame}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> example  # elements may display in different order
{False, 42, 3.14159, 'Thorium'}
>>> example.add(42)
>>> example
{False, 42, 3.14159, 'Thorium'}
>>> len(example)
4
>>> help(example.remove)
Help on built-in function remove:

remove(...) method of builtins.set instance
    Remove an element from a set; it must be a member.

    If the element is not a member, raise a KeyError.
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> example.remove(42)
>>> len(example)
3
>>> example
{False, 3.14159, 'Thorium'}
>>> example.remove(50)
... ...
KeyError: 50
>>> help(example.discard)
Help on built-in function discard:

discard(...) method of builtins.set instance
    Remove an element from a set if it is a member.
    If the element is not a member, do nothing.
\end{minted}
\end{frame}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> example.discard(50)
>>> len(example)
3
>>> example.clear()
>>> leng(example)
0
>>> odds = set([1, 3, 5, 7, 9])
>>> evens = set([2, 4, 6, 8, 10])
>>> primes = set([2, 3, 5, 7])
>>> composites = set([4, 6, 8, 9, 10])
>>> odds.union(evens)
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
>>> evens.union(odds)
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> odds
{1, 3, 5, 7, 9}
>>> evens
{2, 4, 6, 8, 10}
>>> odds.intersection(primes)
{3, 5, 7}
>>> primes.intersection(evens)
{2}
>>> evens.intersection(odds)
set()
>>>  primes.union(composites)
{2, 3, 4, 5, 6, 7, 8, 9, 10}
>>> 2 in primes
True
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Set}
\begin{minted}{python}
>>> 6 in odds
False
>>> 9 not in evens
True
>>> dir(primes)
... ...
\end{minted}

There are many build-in methods (functions) in \textbf{Set}. Just try them.\\
\textbf{Set} is the data structure that stores \textit{unordered} and \textit{unique} data.
\end{frame}

\subsection{List}

\begin{frame}[fragile]{List}
\begin{minted}{python}
>>> example = list()
>>> example = 
>>> primes = [2, 3, 5, 7, 11, 13]
>>> primes.append(17)
>>> primes.append(19)
>>> primes  # NOTE the order of the data, 
...         # which is different than the set
[2, 3, 5, 7, 11, 13, 17, 19]
>>> primes[0]  # index starts from 0
2
>>> primes[1]
3
>>> primes[2]
5
\end{minted}
\end{frame}

\begin{frame}[fragile]{List}
\begin{minted}{python}
>>> primes[-1]
19
>>> primes[-2]
17
>>> primes[-9]
... ...
IndexError: list index out of range
>>> # Slicing. NOTE slicing includes the starting index,
... #               BUT excludes the stopping index.
>>> primes[2:5]
[5, 7, 11]
>>> primes[0:6]
[2, 3, 5, 7, 11, 13]
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{List}
Many languages require the list (array) contain the same type of data, 
but \textbf{NOT} Python.\\
\begin{minted}{python}
>>> example = [128, True, "Alpha", 1.732, [64, False]]
>>> rolls = [4, 7, 2, 7, 12, 4, 7]
>>> rolls  # NOTE the repeated values are all there, 
...        # different than the set.
[4, 7, 2, 7, 12, 4, 7]
>>> numbers = [1, 2, 3]
>>> letters = ['a', 'b', 'c']
>>> numbers + letters  # Concatenation
[1, 2, 3, 'a', 'b', 'c']
>>> letters + numbers
['a', 'b', 'c', 1, 2, 3]
\end{minted}
\end{frame}

\begin{frame}[fragile]{List}
\begin{minted}{python}
>>> numbers
[1, 2, 3]
>>> letters
['a', 'b', 'c']
>>> dir(numbers)
[ ... ... ]
>>> help(numbers.reverse)
Help on built-in function reverse:

reverse() method of builtins.list instance
    Reverse *IN PLACE*.
>>> 
\end{minted}
There are many build-in methods (functions) for the List. Just try them.
\end{frame}

\subsection{Dictionary}

\begin{frame}[fragile]{Dictionary}
\begin{minted}{python}
>>> # FriendFace post
... # User\_id = 209
... # message = "D5 E5 C5 C4 G4"
... # language = "English"
... # datetime = "20230215T1242317"
... # location = (44.590533, -104.715556)
... 
>>> post = {"User_id":209, "message":"D5 E5 C5 C4 G4",
... "language":"English", "datetime":"20230215T1242317",
... "location":(44.590533, -104.715556)}
>>> type(post)
<class 'dict'>
>>> 
\end{minted}
\end{frame}

\begin{frame}[fragile]{Dictionary}

\begin{center}
\begin{tabular}{ |l|l| }
  \hline
  \textbf{Key} & \textbf{Value} \\
  \hline
  User\_id     & 209 \\
  \hline
  message      & "D5 E5 C5 C4 G4" \\
  \hline
  language     & "English" \\
  \hline
  datetime     & "20230215T1242317" \\
  \hline
  location     & (44.590533, -104.715556) \\
  \hline
\end{tabular}
\end{center}

\begin{minted}[fontsize=\small]{python}
>>> post2 = dict(message="SS Cotopaxi", language="English")
>>> print(post2)
{'message': 'SS Cotopaxi', 'language': 'English'}
>>> post2["user_id"] = 209
>>> post2["datetime"] = "19771116T093001Z"
>>> print(post2)
{'message': 'SS Cotopaxi', 'language': 'English', 
  'user_id': 209, 'datetime': '19771116T093001Z'}
\end{minted}

\end{frame}

\begin{frame}[fragile]{Dictionary - Accessing Data in Dictionary}
\begin{minted}[fontsize=\small]{python}
>>> print(post['message'])
D5 E5 C5 C4 G4
>>> print(post2['location'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'location'
>>> if 'location' in post2:
...     print(post2['location'])
... else:
...     print("The post does not contain a location value.")
...
The post does not contain a location value.
>>> 
\end{minted}
\end{frame}

\begin{frame}[fragile]{Dictionary - Accessing Data in Dictionary}
\begin{minted}[fontsize=\small]{python}
>>> try:
...     print(post2['location'])
... except KeyError:
...     print("The post does not have a location.")
...
The post does not have a location.
>>> dir(post2)
[ ... ..., 'get', ... ...]
>>> help(post2.get)
Help on built-in function get:

get(key, default=None, /) method of builtins.dict instance

    Return the value for key if key is in the dictionary, 
    else default.
>>> 
\end{minted}
\end{frame}

\begin{frame}[fragile]{Dictionary - Accessing Data in Dictionary}
\begin{minted}[fontsize=\footnotesize]{python}
>>> loc = post2.get('location', None)
>>> print(loc)
None
>>> print(post)
{'User_id': 209, 'message': 'D5 E5 C5 C4 G4', 'language': 'English', 
  'datetime': '20230215T1242317', 'location': (44.590533, -104.715556)}
>>> for key in post.keys():
...     value = post[key]
...     print(key, "=", value)
...
User_id = 209
message = D5 E5 C5 C4 G4
language = English
datetime = 20230215T1242317
location = (44.590533, -104.715556)
>>>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Dictionary - Accessing Data in Dictionary}
NOTE: Dictionary is also unordered data structure, like set.
\begin{minted}{python}
>>> for key, value in post.items():
...     print(key, "=", value)
...
User_id = 209
message = D5 E5 C5 C4 G4
language = English
datetime = 20230215T1242317
location = (44.590533, -104.715556)
>>> dir(post)
[ ... ..., 'clear', 'pop', 'popitem', ... ... ]
\end{minted}
\end{frame}

\subsection{Tuple}

\begin{frame}[fragile]{Tuples}
\begin{minted}{python}
# List example
prime_numbers = [2, 3, 5, 7, 11, 13, 17]

# Tuple example
perfect_squares = (1, 4, 9, 16, 25)

# Display lengths
print("# of Primes = ", len(prime_numbers))
print("# of Squares = ", len(perfect_squares))
# of Primes = 7
# of Squares = 6
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tuples}
\begin{minted}{python}
for p in prime_numbers:
    print("Prime: ", p)

for n in perfect_squares:
    print("Square: ", n)

# Prime: 2
# Prime: 3
# Prime: 5
... ...
# Square: 1
# Square: 4
# Square: 9
... ...
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tuple}
\begin{minted}{python}
print('List methods:')
print(dir(prime_numbers))
print('-'*80)  # Guess what does this line do?
print('Tuple methods:)
print(dir(perfect_squares))
\end{minted}
List has more build-in methods available than Tuple.\\
This extra functionality comes at a price: list occupies more
memory than tuple.
\begin{minted}{python}
import sys
print(dir(sys))
# [..., 'getsizeof', ...]
help(sys.getsizeof)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tuple}
\begin{minted}{python}
# Help on built-in function getsizeof in module sys:

# getsizeof(...)
#     getsizeof(object, default) -> int
#     Return the size of object in bytes.
list_eg = [1, 2, 3, 'a', 'b', 'c', True, 3.14159]
tuple_eg = (1, 2, 3, 'a', 'b', 'c', True, 3.14159)

print("size list = ", sys.getsizeof(list_eg))
print("size tuple = ", sys.getsizeof(tuple_eg))
# size lsit = 128
# size tuple = 112
\end{minted}
If you are working with big datasets, the more memory 
occupied by list can be significant.
\end{frame}

\begin{frame}[fragile]{Tuple}
\begin{columns}[T]
\column{.3\textwidth}
\textbf{List}
\begin{itemize}
\item Add data
\item Remove data
\item Change data
\end{itemize}
\column{.7\textwidth-1cm}
\textbf{Tuple}
\begin{itemize}
\item Cannot be changed
\item "Immutable"
\item Made quickly
\end{itemize}
\end{columns}
\vspace{10pt}
Knowing tuple is immutable enables Python to make 
significant optimizations.
\begin{minted}{python}
import timeit
list_test = timeit.timeit(stmt="[1,2,3,4,5]", 
                          number=1000000)
tuple_test = timeit.timeit(stmt="(1,2,3,4,5)",
                            number=1000000)
print("List time: ", list_test)  # 0.08 ...
print("Tuple time: ", tuple_test)  # 0.02 ...
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tuple}
\begin{minted}{python}
empty_tuple = ()
test1 = ('a')
test2 = ('a', 'b')
test3 = ('a', 'b', 'c')
print(empty_tuple)  # ()
print(test1)        # \textcolor{red}{a}
print(test2)        # ('a', 'b')
print(test3)        # ('a', 'b', 'c')
# test1 is just a string, not a tuple
test1 == 'a'        # True
# to make a real tuple with single element
# need to add a comma
print(('a',))       # ('a',)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Alternative Construction of Tuple}
\begin{minted}{python}
test1 = 1,    # NOTE the end comma
test2 = 1, 2
test3 = 1, 2, 3

print(test1)    # (1,)
print(test2)    # (1, 2)
print(test3)    # (1, 2, 3)

print(type(test1))  # <class 'tuple'> 
print(type(test2))  # <class 'tuple'>
print(type(test3))  # <class 'tuple'>
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tuple Assignment}
\begin{minted}[fontsize=\small]{python}
# (age, country, knows\_python)
survey = (27, "Vietnam", True)

age = survey[0]
country = survey[1]
knows_python = survey[2]

print("Age =", age)   # Age = 27
print("Country =", country)   # Country = Vietnam
print("Knows Python?", knows_python)  # Knows Python? True

survey2 = (21, "Switzerland", False)
age, country, know_python = survey2
print(age, country, know_python)  # 21 Switzerland False
\end{minted}
\end{frame}

\begin{frame}[fragile]{Recap}
\begin{minted}{python}
country = ("Australia")   # This is just a string
# According to the rules of tuple assignment, this would\\
# assign the string '\textit{Australia}' to the variable \textit{country}.

country = ("Australia",)  # This is a tuple with 
                          # single element
# By adding the comma here, you tell python you do want\\
# \textit{country} to be a tuple, and you donot want to unpack\\
# the values into the variable.

a, b, c = (1, 2, 3, 4)    # \textcolor{red}{ValueError: too many values}
                          # \textcolor{red}{to unpack (expected 3)}
x, y, z = (1, 2)  # \textcolor{red}{ValueError: not enough values to}
                  # \textcolor{red}{unpack (expected 3, got 2)}
\end{minted}
\end{frame}

\end{document}
